package day0316;
// 객체(Object)
// 프로그래밍 언어의 발전 역사를 살펴보면
// 세대를 관통하는 중요한 키워드가 바로
// "코드의 재사용성" 이다.
// 2세대 절차지향적 언어가 나왔던 이유는
// 내가 어저께 구현한 기능을 오늘 다시 쓸려고 보니
// 처음부터 다시 구현했어야 했고, 그것이 "귀찮아서"
// 기능을 재사용하는 2세대 절차지향적 언어가 나왔던 것이다.
// 하지만 처음과는 달리 단순히 기능만 재사용하는 것보다
// 좀더 복합적인 개념을 재사용하게 사람들이 생각하게 됐고
// 그렇게 3세대 언어 "객체 지향적 언어(Object Oriented Programming)"이 탄생하게 된 것이다.

// 객체란 무엇인가?
// 객체는 클래스의 변수를 뜻한다.
// 즉 객체 지향 프로그래밍에서는 우리가 단순히 데이터를 저장할 구조체
// 혹은 기능을 단독적으로 재사용하는 것이 아니라
// 그 모든 것이 합쳐져 있는 클래스 자체를 통째로 재사용하는 것을 지향한다.
// 즉, 프로그램을 기능의 집합으로 생각하던 절차 지향적 프로그래밍과는 다르게
// 객체 지향 프로그래밍에서는 프로그램을 더 작은 프로그램들의 집합으로 보게 된다.

// 프로그램이란?
// "어떤 목적을 달성하기 위한 명령문들의 집합체"

// 프로그램을 더 작은 프로그램의 집합으로 본다는 것은
// 우리가 어떤 객체를 만들어서 그 객체의 메소드를 실행시켜서 그 결과값을 받아보게 되는데
// 커다란 주 프로그램에서는 그 작은 프로그램들 내부가 어떻게 돌아가는지 알 필요 없다.
// 또한, 여러분들이 필요에 따라서는 작은 프로그램들도 만들게 되겠지만,
// 그 작은 프로그램들을 모아서 하나의 커다란 프로그램을 만들어 목적을 달성하는게 주가 된다.

// 클래스는 내부적으로 필드와 메소드로 이루어져 있다.
// 필드: 해당 클래스 변수 안에 어떤 값을 저장할지 지정한 것.
// 메소드: 해당 클래스 변수들이 공통적으로 실행시킬 수 있는 기능

// static 키워드
// static이 붙은 메소드는 우리가 클래스 변수를 선언하지 않고도 곧장 사용 가능하다.
// 절차지향적 관점에서는 매우 올바른 방법이지만 객체지향적 관점에서는?
// 당연히 매우 잘못된 일이다. 왜냐하면 우리가 어떤 기능을 클래스에서 끌어다 쓸 때에는
// 그 클래스 변수를 선언하여 힙 영역 공간에 해당 클래스에 필요한 공간을 마련해서
// 거기서 내부적으로 해당 기능을 실행하는 식으로 진행이 되는데, 만약 static이 붙을 경우
// 해당 메소드의 모든 코드 내용을 전부 실행 영역(method 영역)에 등록시켜버리기 때문이다.
// 따라서 우리는 앞으로, 우리가 만드는 프로그램 안에는 오직 메인 메소드만 static 메소드가 된다.

// 상속(Inheritance)
// 프로그래밍에서의 상속이란 부모 클래스의 코드를 자식 클래스가 한번 더 적어주지 않더라도
// 그대로 받아서 쓸 수 있게 만드는 것이다.
// 자바의 모든 클래스는 java.lang.Object를 직간접적으로 상속을 받게 된다.
// 직접적으로 상속을 받는 경우는 바로 윗부모가 java.lang.Object인 경우이고
// 간접적으로 상속을 받는 경우는 윗부모가 다른 클래스지만 최종적으로 가장 높은 부모가 java.lang.Object인 경우이다.
// 단, 부모 클래스가 물려준 메소드가 반드시 자식 클래스가 쓰기 편하다는 보장은 없다.
// 따라서 필요에 따라서는 부모 클래스가 물려준 메소드 대신 자식 클래스가 똑같은 이름의 메소드를
// "재정의" 해주어야 하는데 이러한 메소드의 재정의를 우리는 "오버라이드(Override)"라고 부른다.
// 단, 오버라이드를 할 때 주의할 점은 메소드의 선언식이 부모 클래스의 해당 메소드의 선언식과
// 완전히 똑같아야 한다는 것이다.

// 오버로드(Overload)
// 오버로드란, 똑같은 이름의 메소드를 파라미터만 다르게 해서 여러개를 만들어주는 방법이다.
// 이름을 통일시킴으로써, 우리가 똑같은 목표를 가진 메소드를 다양한 파라미터에 대비해줄 수 있게 된다.

// 생성자(Constructor)
// 생성자란, 해당 클래스의 변수가 생성될 때 필드의 초기값이나
// 추가적인 작업이 필요할 경우 작성하는 특수한 메소드이다.

// 우리가 특별히 생성자를 만들어주지 않더라도 자바가 기본적으로 제공해주는 생성자가 있는데
// 이 기본 생성자의 경우, 해당 클래스 변수의 필드를 초기화만 하는 역할을 한다.
// 초기화 시에, 만약 해당 필드가 기본형 데이터타입이면 0으로 초기화를 하고,
// 참조형 데이터타입의 필드일 경우에는 null로 초기화한다.

// 필요에 따라서는 우리가 직접 생성자를 만들어 줄 수도 있는데
// 이 때 주의할 점은 만약 파라미터가 있는 생성자만 만들어주면
// 더이상 파라미터가 비어있는 생성자를 호출할 수 없다.
// 만약 여러분들의 객체(=클래스 변수)가 파라미터가 있는 생성자와
// 파라미터가 없는 생성자 모두 필요하다면 둘 다 만들어주어야 한다.


public class Ex01Object {
    public static void main(String[] args) {
        // Student 객체 선언 및 초기화
        Student s = new Student(30, "aaa", 20, 20, 21);
        // 초기화 직후 저장된 값 출력
        s.printInfo();
        // 필드에 값 저장
        s.id = 1;
        s.name = "권은지";
        s.korean = 80;
        s.english = 80;
        s.math = 80;
        // 저장 후 값 출력
        s.printInfo();
        
        // Student 객체 s2 생성 후 값 저장   
        Student s2 = new Student();
        s.id = 2;
        s.name = "bbb";
        s.korean = 90;
        s.english = 91;
        s.math = 91;
        // s2 출력
        s.printInfo();
        
        
        // Student 객체 s3와 s4 생성 후 파라미터가 있는 생성자를 통해 똑같은 값 입력
        Student s3 = new Student(30, "aaa", 20, 20, 21);
        Student s4 = new Student(30, "aaa", 20, 20, 21);
        
        // s3 와 s4의 정보 출력
        System.out.println("\n=================================");
        System.out.println("s3의 정보");
        System.out.println("=================================");
        s3.printInfo();
        System.out.println("=================================");
        
        System.out.println("\n=================================");
        System.out.println("s4의 정보");
        System.out.println("=================================");
        s4.printInfo();
        System.out.println("=================================");
        
        // s3.equals(s4)?
        System.out.println("s3.equals(s4): "+s3.equals(s4));
    }

}
